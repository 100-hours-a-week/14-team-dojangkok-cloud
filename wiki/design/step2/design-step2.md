# 2단계 : CI 파이프라인 구축

- 작성일: 2026-01-07
- 최종수정일: 2026-01-15

## 개요

**도장콕**은 임차인의 부동산 임대 계약 과정(계약 전·계약 중)을 지원하는 서비스입니다. <br>
핵심 기능: 쉬운 계약서(해설+리스크 검증) | 집노트(답사/비교/체크리스트) | 임대 매물 커뮤니티

**본 문서**: CI(지속적 통합) 파이프라인 구축을 다룹니다. GitHub Actions 기반으로 코드 품질 검증, 빌드 자동화, 아티팩트 관리를 구성하여 안정적인 배포 기반을 마련합니다.

본 문서 범위: MVP 2단계 CI(지속적 통합) 파이프라인 설계·구축이며, CD(지속적 배포)·컨테이너화는 후속 단계에서 다룹니다.

## 목차

1. [도장콕 현황](#1-도장콕-현황)
   - [기술 스택 및 레포지토리 구조](#11-기술-스택-및-레포지토리-구조)
   - [팀내 코드관리 방법](#12-팀내-코드관리-방법)
2. [현재 상황의 문제점](#2-현재-상황의-문제점)
   - [위험 요소 분석](#21-위험-요소-분석)
   - [CI 도입 필요성](#22-ci-도입-필요성)
 3. [CI 도구 선택](#3-ci-도구-선택)
     - [도장콕 서비스 환경](#31-도장콕-서비스-환경)
       - [현재 환경](#311-현재-환경)
       - [환경에서 도출된 선택 기준](#312-환경에서-도출된-선택-기준)
     - [CI 도구 비교](#32-ci-도구-비교)
       - ["관리 포인트" 관점 요약](#321-관리-포인트-관점-요약)
       - [도구별 상세 비교](#322-도구별-상세-비교)
     - [GitHub Actions 선택](#33-github-actions-선택)
       - [선택 이유](#331-선택-이유)
       - [감수할 것](#332-감수할-것)
4. [브랜치 전략과 CI 트리거](#4-브랜치-전략과-ci-트리거)
   - [브랜치 전략](#41-브랜치-전략)
     - [브랜치 구조](#411-브랜치-구조)
     - [핫픽스 브랜치](#412-핫픽스-브랜치)
     - [전략 선택 근거](#413-전략-선택-근거)
   - [CI 트리거](#42-ci-트리거)
     - [트리거 매트릭스](#421-트리거-매트릭스)
     - [이벤트 선택 근거](#422-이벤트-선택-근거)
     - [실행 전략 선택 근거](#423-실행-전략-선택-근거)
     - [설정 예시](#424-설정-예시-github-actions)
   - [품질 보장 대책](#43-품질-보장-대책)
     - [현재 대책](#431-현재-대책-mvp-단계)
     - [향후 도입 계획](#432-향후-도입-계획)
     - [현재 한계](#433-현재-한계)
5. [CI 파이프라인 단계](#5-ci-파이프라인-단계)
   - [단계별 설명](#51-단계별-설명)
   - [Build 단계 특이사항](#52-build-단계-특이사항)
6. [실패 시 대응 방안](#6-실패-시-대응-방안)
   - [알림 방식](#61-알림-방식)
   - [Discord 알림 예시](#62-discord-알림-예시)
   - [재시도 방식](#63-재시도-방식)
7. [CI 결과 활용](#7-ci-결과-활용)
   - [빌드 아티팩트 → CD 연계](#71-빌드-아티팩트--cd-연계)
   - [Branch Protection Rule](#72-branch-protection-rule)
- [다음 단계](#다음-단계)
- [부록 A: Lint 심화](#부록-a-lint-심화)
- [부록 B: CI 도구별 상세 비교](#부록-b-ci-도구별-상세-비교)

---

## 1. 도장콕 현황

### 1.1 기술 스택 및 레포지토리 구조

```
도장콕 서비스
├── Frontend (React)      ← GitHub 레포 #1
├── Backend (Spring Boot) ← GitHub 레포 #2
└── AI Server (FastAPI)   ← GitHub 레포 #3
```

- **멀티레포** 운영: 각 파트별 독립적인 GitHub 저장소
- **팀 규모**: 6명
  - 풀스택(FE) 1명
  - 풀스택(BE) 1명
  - AI 2명
  - Cloud 2명
- **배포 환경**: AWS EC2 (컨테이너 미사용, 직접 빌드)

### 1.2 팀내 코드관리 방법

| 항목 | 현재 상태 |
|------|----------|
| 린트 검사 | 각 개발자가 로컬에서 수동 실행 |
| 테스트 | 각 개발자 재량에 위임 |
| 빌드 검증 | 배포 시점에 서버에서 직접 수행 |
| 코드 스타일 | 구두 합의, 강제 검증 없음 |

<br>

## 2. 현재 상황의 문제점

### 2.1 위험 요소 분석


| 위험 | 발생 시나리오 |
|------|-------------|
| **코드 컨벤션 일관성 저하** | 개발자마다 다른 코딩 스타일 적용 → 코드베이스 혼재 |
| **테스트 누락** | 급한 기능 추가 시 테스트 없이 머지 |
| **빌드 실패 발견 지연** | 배포 시점에야 빌드 오류 발견 → 긴급 대응 |
| **런타임 환경 불일치** | 로컬과 서버의 런타임 환경, 패키지 버전 차이 |

### 2.2 CI 도입 필요성

위 문제들을 방치하면 버그 수정 비용이 기하급수적으로 증가한다.<sup>[1]</sup>

| 발견 시점 | 상대적 수정 비용 |
|----------|----------------|
| 구현 단계 | 1x |
| 테스트 단계 | 3x |
| 운영 단계 | 10x+ |

<sub>[1] IBM Systems Sciences Institute 연구. 운영 단계에서 발견된 버그는 구현 단계 대비 최대 100배 비용 증가.</sub>

CI 도입으로 위 문제들을 해결할 수 있다:

1. **자동화된 검증**: 수동 검토 누락 방지, "깜빡함" 제거
2. **일관된 환경**: 로컬 개발 환경과 서비스 배포 환경 차이에서 발생하는 문제 감소
3. **빠른 피드백**: 코드 관련 문제 발생 시 수 분 내 알림
4. **팀 규칙 강제화**: 구두 약속 → 시스템 강제

<br>

## 3. CI 도구 선택

### 3.1 도장콕 서비스 환경

#### 3.1.1 현재 환경

| 항목 | 현황 |
|------|------|
| 팀 규모 | 6명 (풀스택 2명, AI 2명, Cloud 2명) |
| CI 담당 | Cloud 2명 |
| 레포지토리 | GitHub 기반 멀티레포 3개 (FE, BE, AI) |
| 레포 공개 여부 | 모두 Public |
| 배포 환경 | FE/BE: AWS EC2, AI: GCP GPU 인스턴스 |
| 프로젝트 문서 | GitHub Wiki를 중앙 저장소로 활용 |
| 개발 단계 | MVP 단계, 빠른 개발 우선 |

#### 3.1.2 환경에서 도출된 선택 기준

| 환경 | 영향 | 도출된 선택 기준 |
|------|------|-----------------|
| 팀 6명, CI 담당 2명 | CI 외에도 AWS/GCP 인프라 운영 담당 | **관리 포인트 최소화** |
| GitHub 멀티레포 3개 | 이미 GitHub 중심 운영 | **GitHub 네이티브 통합** |
| Public 레포 | GitHub Actions 무료 사용 가능 | **비용 0원** |
| MVP 단계 | 빠른 개발 우선 | **설정 단순성** |

### 3.2 CI 도구 비교

#### 3.2.1 "관리 포인트" 관점 요약

| 도구 | 서버 운영 | 플러그인/버전 관리 | GitHub 연동 | 관리 부담 |
|------|----------|------------------|-------------|----------|
| **GitHub Actions** | 불필요 | GitHub 관리 | 네이티브 | **최소** |
| CircleCI | 불필요 | CircleCI 관리 | OAuth 연동 | 낮음 |
| GitLab CI | 불필요* | GitLab 관리 | 저장소 이전 필요 | 중간 |
| Travis CI | 불필요 | Travis 관리 | OAuth 연동 | 낮음 |
| Jenkins | **필수** | **직접 관리** | 플러그인 설정 | **최대** |
| Buildkite | **필수** (runner) | 직접 관리 | OAuth 연동 | 높음 |
| TeamCity | **필수** | 직접 관리 | 플러그인 설정 | 높음 |

> *GitLab CI는 서버 운영 불필요하나, GitHub → GitLab 저장소 이전이 전제되어 초기 전환 비용 발생

#### 3.2.2 도구별 상세 비교

| 도구 | 강점 및 미선택 사유 |
|------|-------------------------|
| **GitLab CI** | 올인원 DevOps 플랫폼으로 보안 스캔, 컨테이너 레지스트리가 내장되어 있다. 다만 GitHub → GitLab 저장소 이전이 전제되며, 현재 GitHub Wiki/Issue 기반 운영 중이라 이전 비용이 이점보다 크다. 무료 티어 월 400분은 3개 레포 운영에 부족. |
| **CircleCI** | 테스트 병렬 분할, 직관적인 UI, 빠른 실행 속도가 강점이다. 다만 GitHub 외부에 추가 플랫폼 관리가 필요하여 관리 포인트가 분산된다. 무료 티어 월 6,000분(조직 전체)은 현재 충분하나 팀 확장 시 유료 전환 필요. 현재 단순한 파이프라인에서 CircleCI 강점 활용 어려움. |
| **Jenkins** | 완전한 커스터마이징이 가능하고 1,800개 이상의 플러그인을 제공한다. 다만 별도 서버 운영이 필수이며 프로비저닝, OS 업데이트, 버전 관리, 플러그인 호환성 관리가 필요하다. 6명 팀에서 CI 인프라 관리에 리소스를 할애하기 어렵고, 현재 단순한 파이프라인에 Jenkins 수준의 유연성은 불필요. |
| **Buildkite** | 자체 인프라와 관리형 UI를 결합한 하이브리드 방식으로, 대규모 빌드 처리에 강점이 있다. 다만 Self-hosted runner 운영이 필수이며, 6명 팀에서 추가 인프라 관리는 부담이다. 무료 티어는 월 5,000분이나 runner 비용이 별도 발생. |
| **Travis CI** | 오픈소스 프로젝트에서 널리 사용되었고 GitHub과 쉽게 연동된다. 다만 2020년 이후 무료 티어 축소, 2025년 4월 macOS 지원 중단 등 기능 축소 추세다. 장기적 안정성에 불확실성이 있어 신규 도입에 부적합. |
| **AWS CodePipeline** | AWS 서비스(CodeBuild, CodeDeploy, ECR 등)와 네이티브 통합이 강점이다. 다만 GitHub 중심 워크플로우와 맞지 않고 AWS 콘솔에서 별도 관리가 필요하다. FE/BE는 AWS에 배포되나, CI까지 AWS로 가면 GitHub에서 빌드 상태 확인이 불편. |
| **TeamCity** | JetBrains IDE 통합, 강력한 빌드 설정 UI, 빌드 체인 기능이 강점이다. 다만 서버 운영이 필요하고 무료 티어는 빌드 에이전트 3개로 제한된다. 클라우드 버전도 있으나 월 $45부터 시작하여 비용 부담. |
| **Bitbucket Pipelines** | Jira, Confluence와 네이티브 통합되어 Atlassian 생태계에서 강점이 있다. 다만 Bitbucket 저장소 사용이 전제되며, 현재 GitHub 운영 중이라 저장소 이전이 필요하다. 무료 티어 월 50분은 3개 레포에 부족. |
| **Azure Pipelines** | 엔터프라이즈 규모 지원, YAML/클래식 UI 선택, Microsoft 생태계 통합이 강점이다. 다만 Azure 종속성이 발생하고 현재 AWS를 사용 중이다. 무료 티어 월 1,800분은 충분하나 클라우드 분산으로 관리 복잡도 증가. |
| **Google Cloud Build** | 서버리스 CI/CD, SLSA level 3 보안 인증, 월 2,500분 무료가 강점이다. AI Server가 GCP GPU 인스턴스에 배포되어 Cloud Build 연동 시 이점이 있다. 다만 FE/BE는 AWS에 배포되어 CI 도구가 분산된다. GitHub Actions로 통일하여 3개 레포 일관된 CI 운영 선택. |

> 각 도구의 상세 강점/약점은 [부록 B: CI 도구별 상세 비교](#부록-b-ci-도구별-상세-비교) 참조

### 3.3 GitHub Actions 선택

위 비교를 기반으로 10개 이상의 CI 도구를 검토한 결과, **GitHub Actions**를 선택했다.

#### 3.3.1 선택 이유

| 선택 기준 | GitHub Actions 충족 방식 |
|----------|-------------------------|
| **관리 포인트 최소화** | GitHub가 러너 인프라 운영. CI 서버 장애 대응, 보안 패치, 버전 업데이트를 GitHub에 위임. |
| **GitHub 네이티브 통합** | PR, Issue, 코드와 같은 공간에서 CI 결과 확인. 컨텍스트 스위칭 없음. |
| **비용 0원** | Public 레포 무제한 무료. 도장콕 3개 레포 모두 Public. |
| **설정 단순성** | `.github/workflows/` 디렉토리에 YAML 파일 추가만으로 CI 구성. 별도 서버/계정 설정 불필요. |

#### 3.3.2 감수할 것

| 항목 | 내용 | 현재 영향 |
|------|------|----------|
| **GitHub 플랫폼 종속** | GitLab/Bitbucket으로 이전 시 워크플로우 전체 재작성 필요 | 낮음. 플랫폼 이전 계획 없음 |
| **복잡한 파이프라인 한계** | 조건부 분기, 동적 매트릭스 등에서 yml 문법이 장황해질 수 있음 | 낮음. 현재 lint → test → build 순차 실행으로 충분 |
| **빌드 환경 커스터마이징 제한** | Self-hosted runner 없이는 실행 환경 세밀 제어 어려움 | 낮음. 표준 Ubuntu + Node/Java/Python 환경으로 충분 |


## 4. 브랜치 전략과 CI 트리거

### 4.1 브랜치 전략
#### 4.1.1 브랜치 구조
- main: 프로덕션 기준선(릴리즈된 안정 버전)
- dev: 다음 릴리즈 후보 통합선(Integration + Release Candidate)
- feature/* : dev에서 분기하여 PR로 dev에 통합
- hotfix/*: 프로덕션 긴급 이슈 시 main에서 분기하여 main에 우선 반영 후, dev로 역반영(backport)

```
main ──────────────────────────────────── (프로덕션, 릴리즈된 안정 버전)
  │ \
  │  └── hotfix/critical-bug ──────────── (긴급 수정, main에서 분기)
  │
  └── dev ─────────────────────────────── (개발 통합, 다음 릴리즈 후보)
        │
        ├── feat/login ────────────────── (기능 개발)
        └── feat/checklist ────────────── (기능 개발)

```
> 참고: dev는 “main의 하위”가 아니라, 다음 릴리즈를 만들기 위한 통합선이며 main은 릴리즈된 결과물의 기준선이다.

#### 4.1.2 핫픽스 브랜치
프로덕션에 영향이 있는 긴급 이슈(장애/보안/데이터 손상 위험 등) 발생 시 main에서 직접 분기한다.

```
main ────┬───────────────────── hotfix 머지 후
         │
         └── hotfix/critical-bug ──→ main (PR)
                                      ↓
                              backport PR → dev (필수)

```

**선택 이유:**
- 플로우가 단순하여 긴급 상황에서 빠른 대응 가능
- main의 현재 프로덕션 상태에서 바로 수정 시작 → 재현/검증 기준이 명확

**주의사항:**
- hotfix/*는 프로덕션 영향 + 긴급성이 있는 경우에만 사용

```
# 핫픽스 PR 체크리스트 (PR 템플릿에 추가)
- [ ] hotfix PR이 main에 머지되었는가?
```

#### 4.1.3 전략 선택 근거

**왜 main - dev 2단계 구조인가?**

| 전략 | 특징 | 도장콕 선택 이유 |
|------|------|-----------------|
| **Git Flow** | main/develop/release/hotfix 분리 | ❌ 6명 팀 + MVP 단계에 과한 프로세스. release/*, hotfix/* 운영·동기화 오버헤드가 큼 |
| **GitHub Flow** | main + feature만 | ⚠️원칙 자체가 위험한 것은 아니지만, MVP 단계에서 main을 “항상 배포 가능(trunk)”로 유지하면서도 통합 검증을 위한 완충 지점이 부족해질 수 있음 |
| **GitHub Flow 변형** | main + dev + feature | ✅dev를 통합 테스트 + 릴리즈 후보(Release candidate) 브랜치로 사용하여 리스크를 낮추고, main의 안정성을 유지 |

**선택 이유:**

1) 팀 규모(6명)와 커뮤니케이션 비용에 적합

- Git Flow의 release/*, hotfix/*까지 포함한 다단계 브랜치 운영은 관리 포인트 증가 → 리뷰/머지 경로 복잡화로 이어짐.

- 도장콕은 dev 하나로 통합(Integration) + 릴리즈 준비를 겸용해, 팀 규모 대비 과도한 프로세스를 줄임.

2) MVP 단계: 속도(빠른 피드백 루프) 우선

- stage 브랜치를 추가하면 머지 경로가 한 단계 더 늘어(예: feature → dev → stage → main) 릴리즈 리드타임이 증가할 수 있음.

- MVP에서는 기능 검증과 반복이 핵심이므로, dev에서 통합 검증 후 main으로 릴리즈하는 단순한 경로를 유지.

3) 비용 효율(환경 운영 비용 최소화)

- 비용 증가의 핵심은 “브랜치 수”가 아니라 “환경 수(서버/DB/모니터링/운영)”임.

- MVP 단계에서는 별도의 staging 환경을 운영하지 않고, dev 배포 환경을 통합 테스트/검증 환경으로 운용하여 운영 비용을 절감.

- 추후 CD 고도화 시에도 우선은 dev 자동 배포를 기반으로 점진 확장 예정.

**감수할 것:**
- staging 환경 없이 품질 보장 필요 → [섹션 4.3](#43-품질-보장-대책)에서 대책 명시

## 4.2 CI 트리거

### 4.2.1 트리거 매트릭스

| 이벤트 | 브랜치(대상) | 실행 작업 |
|---|---|---|
| **PR 생성/업데이트** | `feat/*` → `dev` | lint, test |
| **Push** | `dev` | lint, test, build |
| **PR 생성/업데이트** | `dev` → `main` | lint, test, build |
| **PR 생성/업데이트** | `hotfix/*` → `main` | lint, test, build |
| **Push** | `main` | artifact |

> **운영 규칙(권장)**: `main`으로의 PR source는 `dev` 또는 `hotfix/*`만 허용(Branch Rule/보호 규칙으로 제한)

<br>


### 4.2.2 이벤트 선택 근거

#### 왜 `push`와 `pull_request` 이벤트인가?

| 이벤트 | 설명 | 도장콕 선택 이유 |
|---|---|---|
| **push** | 브랜치에 코드 푸시 시 실행 | ✅ **통합 직후 검증**. `dev/main` 반영 시점에 즉시 빌드/테스트 확인 |
| **pull_request** | PR 생성/업데이트 시 실행 | ✅ **머지 전 사전 검증**. 문제 있는 코드 유입 차단(Branch Protection과 결합) |
| workflow_dispatch | 수동 버튼 클릭 시 실행 | △ CI 목적은 자동화. 다만 장애/재현 상황에서 수동 재실행 용도로는 확장 가능 |
| schedule | 크론 스케줄 실행 | ❌ MVP에서는 변경 없는 주기 실행은 우선순위 낮음. “변경 시점 검증”이 핵심 |
| release | GitHub Release 생성 시 실행 | ❌ 현재는 `main`에 머지 시 semantic-release로 자동 릴리즈 생성 예정 → 별도 트리거 불필요(필요 시 확장 가능) |

**선택 이유**
- **즉각적 피드백**: 코드 변경 시점에 바로 검증 → 문제 발견이 빠름
- **자동화**: 개발자가 수동으로 CI 실행할 필요 없음
- **PR 중심 워크플로우**: GitHub Flow 변형(`main/dev/feature/*`, 4.1.3)에 맞는 트리거 조합

<br>

### 4.2.3 실행 전략 선택 근거

#### 왜 “이벤트 + 브랜치별 차등 실행” 전략인가?

> **용어 정의**: 여기서 `build`는 배포 단위 생성(예: 패키징)을 의미한다.  
> (`test`는 기본적으로 컴파일을 포함하되, 매번 배포 단위 생성까지 수행하지는 않음)

| 접근 방식 | 설명 | 도장콕 선택 이유 |
|---|---|---|
| **전체 실행** | 모든 이벤트에서 lint+test+build+artifact | ❌ BE 기준 3분+ 소요(예: 배포 단위 생성 포함) → 피드백 지연으로 개발 속도 저하 |
| **PR만 실행** | push 트리거 없이 PR 이벤트만 검증 | ❌ `dev` 통합 후에만 드러나는 문제(충돌/의존성/통합 환경 차이) 발견이 지연될 수 있음 |
| **차등 실행** | 이벤트+브랜치별 필요한 작업만 실행 | ✅ 빠른 피드백 + 통합 검증 + 릴리즈 단위 관리(아티팩트 생성 지점 명확) |

**선택 이유**
1. **피드백 속도**
   - `feat/* → dev` PR에서 배포 단위 생성까지 하면 대기 시간 증가 → 개발 흐름 단절
   - PR에서는 `lint+test` 중심으로 1–2분 내 피드백을 목표(수정 비용 감소)

2. **통합 검증**
   - `dev` push 시 `build` 수행 → 통합 후 깨짐을 조기에 발견
   - PR만 검증하면 “통합 이후 문제”가 늦게 드러날 수 있음

3. **릴리즈 관리**
   - `main` push 시에만 `artifact` 생성 → CD에서 사용하는 배포 후보가 명확
   - PR 단계 artifact는 CD에서 미사용 (중복 제거)

**감수할 것**
- `feat` PR 단계에서 “배포 단위 생성(build)” 실패가 즉시 드러나지 않을 수 있음  
  → `dev` 통합 시점의 push CI에서 발견(최대 지연: 다음 통합까지)


<br>

### 4.2.4 설정 예시 (GitHub Actions)

#### 기본 트리거
```yaml
on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main, dev]  # base branch 기준: dev로 들어오는 PR, main으로 들어오는 PR 모두 감지
```

**핫픽스 브랜치 동작 설명**

- hotfix/* → main PR은 pull_request: branches: [main] 조건에 의해 감지됨
- 따라서 dev → main PR과 동일하게 lint, test, build를 수행하도록 매트릭스에 포함 (artifact는 main push에서 생성)

### 4.3 품질 보장 대책

**핵심 질문: "staging 환경 없이 어떻게 프로덕션 품질을 보장하는가?"**

#### 4.3.1 현재 대책 (MVP 단계)

| 대책 | 설명 |
|------|------|
| **CI 자동 검증** |  lint/test/build 정책 적용. Branch Protection Rule로 실패 시 머지 차단 |
| **롤백 계획** |  문제 발생 시 `git revert` + 재배포. 이전 배포 단위(artifact)로 즉시 롤백 가능(보관 7일) |

**dev → main PR 체크리스트:**
```
## 릴리즈 전 확인사항
- [ ] 신규 기능 시나리오 로컬 테스트 완료
- [ ] 기존 기능 테스트 완료(수동)
- [ ] CI에서 lint, test, build 통과 확인
- [ ] dev 환경에서 핵심 로그/에러 징후 수동 확인(현 단계)
```

#### 4.3.2 향후 도입 계획(검토필요)

| 대책 | 도입 시점 | 효과 |
|------|----------|------|
| **dev 환경 자동 배포(CD)** | CD 구축 시 | dev 머지 → dev 서버 자동 배포 → 팀 내부 사전 검증 루프 강화 |
| **Smoke Test** | CD 구축 후 | 배포 직후 핵심 기능 5-10개 자동 검증(로그인/핵심 API 등) |
| **모니터링/알림** | 서비스 성장기 | 에러율/응답시간 감시 → 이상 시 Discord 자동 알림 |
| **Feature Flags** | 위험 기능 추가 시 | 배포 ≠ 기능 활성화. 점진적 롤아웃으로 위험 분산 |

#### 4.3.3 현재 한계

| 한계 | 영향 | 완화 방안 |
|------|------|----------|
| staging 환경 없음 | 별도 통합 테스트 환경 부재 | 로컬 통합 테스트 + PR 리뷰 강화 + dev 환경 검증 강화(4.3.2) |
| feat PR에서 build(배포 단위) 미검증 | 발견 지연(최대: 다음 통합까지) | dev push에서 build로 조기 발견 + 통합 빈도 증가 |
| Smoke Test 없음 | 배포 후 수동 확인 필요 | 현재는 릴리즈 체크리스트로 수동 점검, CD 이후 자동화 계획 |
| 모니터링 미구축(초기) | 문제 발견 지연 가능 | 로그 수동 확인 + 사용자 피드백 채널 운영 → 성장 시 자동 알림 도입 |

> **MVP 단계 판단**: 초기 사용자/트래픽이 작고 팀이 소규모이므로, "빠른 통합 + 빠른 수정"으로 리스크를 관리한다.
> 서비스 성장에 따라 4.3.2 대책을 추후 변경사항을 반영하여 단계적으로 도입하고자 함.

<br>

## 5. CI 파이프라인 단계

### 5.1 단계별 설명


| 단계 | 목적 | 실패 시 영향 | 서버별 특이사항 |
|------|------|-------------|----------------|
| **Checkout** | 코드 다운로드 | 전체 중단 | 공통 |
| **Setup Runtime** | Node/Java/Python 설치 | 전체 중단 | 버전 통일 중요 |
| **Install Dependencies** | 패키지 설치 | 전체 중단 | 캐시 활용으로 속도 향상 |
| **Lint** | 코드 스타일 및 잠재적 오류 검사 | PR 차단 | FE: ESLint+Prettier, BE: IntelliJ 로컬, AI: Ruff (→ 부록 A 참조) |
| **Test** | 기능 검증 | PR 차단 | MVP 단계로 단위 테스트 중심. 향후 통합 테스트 확대 예정 |
| **Build** | 빌드 가능성 검증 | PR 차단 | Ubuntu 환경에서 검증 (→ 5.2 참조) |
| **Upload Artifact** | 빌드 결과물 저장 | CD 불가 | JAR/build 폴더 저장 (→ 섹션 7 참조) |

### 5.2 Build 단계 특이사항

도장콕은 **컨테이너 환경이 아닌 EC2(Ubuntu)에서 직접 배포**한다.

CI에서 Ubuntu 환경으로 빌드하는 이유:
- 서버 환경(Ubuntu)과 **동일한 환경**에서 빌드 검증
- "로컬에서는 되는데 서버에서 안 됨" 문제 방지
- **빌드 결과물을 CD에서 그대로 사용** → 서버에서 재빌드 불필요

```yaml
jobs:
  build:
    runs-on: ubuntu-latest  # 서버 환경과 동일한 OS
```

<br>

## 6. 실패 시 대응 방안

### 6.1 알림 방식 : Discord Webhook + GitHub PR Comment

### "왜 Discord Webhook 과 GitHub PR Comment를 선택했나요?"

팀이 이미 Discord를 주 커뮤니케이션 채널로 사용 중이다. CI 실패 시 Discord로 즉시 알림이 가면 빠른 대응이 가능하다. GitHub PR Comment는 별도 설정 없이 기본 제공되므로 함께 활용한다.



### 6.2 Discord 알림 예시

```yaml
- name: Discord Notification
  uses: sarisia/actions-status-discord@v1
  if: always()
  with:
    webhook: ${{ secrets.DISCORD_WEBHOOK }}
    title: "CI 결과"
    description: |
      **Branch**: ${{ github.ref_name }}
      **Commit**: ${{ github.event.head_commit.message }}
      **Status**: ${{ job.status }}
```

### 6.3 재시도 방식 : 수동 Re-run

왜 CI 재시도 방식으로 수동 Re-run 을 선택했나요?

1. **CI 실패 원인 분석**
   - MVP 단계에서 대부분의 CI 실패는 코드 문제 (린트 오류, 빌드 실패)
   - 인프라 장애는 드묾 (근거: GitHub Actions 공식 SLA 99.9%, 월 평균 장애 시간 43분 이하<sup>[2]</sup>)
   - 실패 시 로그를 확인하고 원인을 파악하는 과정이 필요함

2. **자동 재시도의 부작용**
   - 실제 코드 문제도 재시도하게 되어 불필요한 CI 시간 소모
   - 재시도 성공 시 원인 파악 없이 넘어갈 위험
   - 실패 알림이 지연됨 (3회 재시도 후에야 알림)

<sub>[2] GitHub Actions SLA는 명시적으로 공개되지 않으나, GitHub Status ([status.github.com](https://www.githubstatus.com/))에서 과거 인시던트 기록을 확인할 수 있다. 2024년 기준 월 1-2회 minor 인시던트가 발생하며, 대부분 30분 이내 해결된다.</sub>

> 자동 재시도 도입 시점: 테스트가 많아져 Flaky test가 빈번해지거나,
> 외부 API 연동 테스트가 추가되어 일시적 실패가 증가할 때 검토


#### **다른 재시도 방식을 선택하지 않은 이유**

| 방식 | 선택하지 않은 이유 |
|------|------------------|
| **자동 재시도** | `nick-fields/retry@v2` 액션으로 Flaky test 대응에 효과적이고, 인프라 일시 장애 시 자동 복구가 가능하다. 다만 실제 코드 문제도 재시도하게 되어 CI 시간이 낭비된다. 재시도 성공 시 원인 파악 없이 넘어가 Flaky test가 누적될 위험이 있다. 실패 알림이 3회 재시도 후에야 도착하여 지연된다. 현재 Flaky test가 거의 없고(MVP 단계, 단위 테스트 중심), 원인 파악을 우선시하여 미선택. |
| **workflow_dispatch** | UI에서 특정 입력값(브랜치, 환경)을 지정하여 수동 실행할 수 있고, PR 없이도 워크플로우 실행이 가능하여 디버깅에 유용하다. 다만 일반적인 재시도 용도로는 과잉 설정이다. 현재 단순한 파이프라인에서 수동 Re-run으로 충분하며, 복잡한 입력 파라미터가 필요한 상황이 아님. |
| **조건부 자동 재시도** | 특정 에러 패턴("npm ERR! network" 등)에만 재시도하여 인프라 장애와 코드 문제를 구분할 수 있다. 다만 설정이 복잡하고 새로운 유형의 장애마다 패턴을 추가해야 한다. 에러 메시지 변경 시 패턴 업데이트가 필요하다. 현재 인프라 장애 빈도가 낮아(GitHub SLA 99.9% 수준) 도입 ROI가 낮음. |

> **인프라 일시 장애란?**: 코드 문제가 아닌 외부 환경 문제로 CI가 실패하는 경우. 예시: GitHub Actions runner 일시 장애, npm registry 연결 실패, 외부 API 타임아웃 등. 동일 코드로 재실행하면 성공하는 경우가 대부분이다.

> **Flaky test란?**: 코드 변경 없이도 때때로 실패하는 불안정한 테스트. 원인: 비동기 타이밍, 외부 의존성, 테스트 간 상태 공유 등.


<br>

## 7. CI 결과 활용

### 7.1 빌드 아티팩트 → CD 연계

CI에서 빌드한 결과물을 저장 → CD에서 재빌드 없이 배포.

**기존 방식 (서버 직접 빌드)**:
- 서버에서 git pull → 빌드 → 서비스 시작
- 빌드 시간(BE 기준 3분+) 동안 서비스 중단

**CI 아티팩트 활용 시**:
- CI에서 미리 빌드 완료 (서버와 동일한 Ubuntu 환경)
- CD는 아티팩트 다운로드 → 서비스 교체만
- 다운타임 대폭 감소

핵심: **CI 통과 = 배포 가능한 빌드 결과물 확보**

```yaml
- name: Upload artifact
  uses: actions/upload-artifact@v4
  with:
    name: build-${{ github.sha }}
    path: build/
    retention-days: 7  # 7일 보관
```

#### 7.1.1 아티팩트 관리 방식 비교 : GitHub Actions Artifacts (7일 보관)

| 방식 | 강점 | 약점 | 도장콕 적합성 |
|------|------|------|-------------|
| **GitHub Actions Artifacts** | 추가 설정 불필요, Public 레포 무료, CI 워크플로우와 통합 | 최대 90일 보관, 500MB/아티팩트 제한, 장기 보관 불가 | **선택** |
| Container Registry | 이미지 버전 관리, 배포 일관성, 롤백 용이 | 컨테이너 환경 전제, 레지스트리 비용 | 해당 없음 (EC2 직접 배포) |
| Cloud Storage (S3) | 무제한 보관, 버전 관리, 수명 주기 정책 | IAM 설정, 버킷 정책, 저장/전송 비용 | 장기 보관 필요 시 검토 |
| Artifactory/Nexus | 의존성 프록시, 취약점 스캔, 라이선스 관리 | 서버 운영 필요, 비용 높음 | 과잉 설정 |

#### "왜 GitHub Actions Artifacts를 선택했나요?"

1. **추가 설정 부담 없음**
   - S3: IAM 역할 생성 → 버킷 정책 설정 → GitHub Secrets 등록 → 워크플로우 수정
   - GitHub Artifacts: `actions/upload-artifact@v4` 한 줄 추가로 완료
   - 6명 팀에서 CI 설정에 할애할 시간 최소화

2. **비용 0원**
   - Public 레포는 GitHub Artifacts 무료 (저장/다운로드 모두)
   - S3는 저장 비용 + 데이터 전송 비용 발생 (소액이나 관리 포인트 추가)

3. **CD 연계 간편**
   - 같은 워크플로우 내에서 `actions/download-artifact`로 바로 사용
   - 워크플로우 간에도 `run_id`로 아티팩트 참조 가능
   - 외부 스토리지 연동 시 인증/네트워크 설정 추가 필요

#### "왜 7일 보관인가?"

2주 릴리즈 주기인데 7일로 설정한 이유:

1. **롤백 대부분 배포 직후 발생**
   - 실제 롤백이 필요한 경우 대부분 배포 후 24-48시간 내 발견
   - 7일이면 최근 배포 3-4회분 아티팩트 보유 (일평균 0.5회 배포 가정)

2. **저장 공간 효율화**
   - 90일 보관 시 불필요한 아티팩트 누적
   - 7일이면 활성 개발 기간만 커버

3. **7일 이후 롤백 필요 시 대안 존재**
   - GitHub Releases에 릴리즈 버전 아티팩트 별도 보관 가능
   - 해당 커밋에서 재빌드 (CI가 빠르므로 부담 적음)

**감수할 것**:

| 포기하는 것 | 대안 | 영향도 |
|------------|------|--------|
| 7일 이후 아티팩트 | GitHub Releases 또는 재빌드 | 낮음 (실제 발생 드묾) |
| 500MB 이상 아티팩트 | S3 업로드 전환 | 현재 해당 없음 (JAR ~50MB) |
| 아티팩트 버전 관리 | 커밋 SHA로 식별 | 충분 |
| 장기 감사 로그 | GitHub Actions 로그 90일 보관 | MVP에서 충분 |

### 7.2 Branch Protection Rule

**"왜 CI 통과를 머지 조건으로 설정하나요?"**

1. **구두 약속의 한계**
   - "린트 돌리고 푸시하자"는 약속은 급할 때 무시되기 쉬움
   - 시스템이 강제하면 예외 없이 품질 기준 충족

2. **코드 리뷰 효율화**
   - CI 통과 후 리뷰하면 기본 품질이 보장된 상태에서 시작
   - 리뷰어가 스타일/빌드 오류 대신 로직/설계에 집중 가능

3. **main 브랜치 보호**
   - 프로덕션 배포 대상인 main에 검증되지 않은 코드 유입 방지
   - 배포 후 장애 발생 가능성 감소

```
GitHub Repository → Settings → Branches → Branch protection rules
→ Require status checks to pass before merging
→ 필수 체크: lint, test, build
```

> 단, 긴급 상황(핫픽스 등)에서 Branch Protection을 우회해야 할 경우,
> Repository Admin이 "Bypass branch protections" 권한으로 강제 머지할 수 있다.
> 이 경우 Discord에 사유를 공유한다.


<br>

## 다음 단계

이 문서는 CI 개요를 다룬다. 각 서버별 구체적인 CI 설정은 아래 문서를 참고:

- Frontend: [[Frontend CI 설정 가이드]]
- Backend: [[Backend CI 설정 가이드]]
- AI Server: [[AI Server CI 설정 가이드]]

<br>

## 부록 A: Lint 심화

<details>
<summary><b>Lint 목적, 방법, 효과, 지표</b></summary>

### 왜 수행해야 하는가

**관점 A: 일관성**
- 팀원마다 다른 코딩 스타일 → 코드 리뷰에서 스타일 논쟁 발생
- "세미콜론 쓸까 말까", "들여쓰기 2칸 vs 4칸" 같은 불필요한 토론

**관점 B: 잠재적 버그 사전 발견**
- 사용되지 않는 변수 → 의도치 않은 로직 누락 신호
- `==` vs `===` 같은 타입 안전성 문제
- null/undefined 체크 누락

**관점 C: 코드 리뷰 효율화**
- 스타일 지적에 시간 낭비 방지
- 리뷰어가 로직/설계에 집중 가능

**관점 D: 암묵지의 형식지화**
- "우리 팀은 이렇게 작성해" → lint 규칙으로 문서화
- 새 팀원 온보딩 시 명확한 기준 제공

### 어떻게 수행할 것인가

**수행 시점 선택지:**

| 시점 | 장점 | 단점 |
|------|------|------|
| 로컬 IDE | 즉각 피드백 | 강제력 없음 |
| pre-commit hook | 커밋 전 차단 | 로컬 설정 필요 |
| CI (PR 시점) | 중앙 강제력 | 피드백 지연 |
| 모든 시점 | 다중 방어선 | 설정 중복 관리 |

**엄격도 수준:**

| 수준 | 설명 | 적합 상황 |
|------|------|----------|
| Minimal | Error만 차단 | 빠른 개발 우선 |
| Moderate | Error + 주요 Warning | 균형 추구 |
| Strict | 모든 Warning 차단 | 품질 최우선 |

### 무엇을 얻고 잃는가

**얻는 것:**
1. 일관된 코드베이스: 누가 작성했든 비슷한 스타일
2. 버그 조기 발견: 런타임 전에 문제 발견 → 디버깅 시간 절약
3. 자동화된 품질 게이트: 사람 판단에 의존하지 않음, 24/7 일관된 기준
4. 코드 리뷰 품질 향상: 스타일 논쟁 제거 → 설계/로직에 집중
5. 기술 부채 누적 방지: 복잡도 높은 함수 조기 발견

**잃는 것:**
1. 초기 설정 비용: 규칙 선정, 팀 합의, 기존 코드 수정
2. CI 시간 증가: 린트 실행 시간 추가 (보통 10-30초)
3. 개발자 자율성 제한: "내 스타일" 포기, 규칙에 대한 불만 가능
4. False positive 대응: 실제 문제없는데 린트 경고 → 불필요한 수정
5. 규칙 관리 부담: 도구 버전 업그레이드 시 새 규칙 대응

### CI 포함 시 방지할 수 있는 문제

| 문제 | 린트 없이 | 린트 있으면 |
|------|----------|------------|
| 스타일 불일치 | 코드 리뷰에서 발견, 수정 요청 | 자동 차단 |
| 사용 안 하는 import | 번들 크기 증가 | 사전 제거 |
| 타입 안전성 문제 | 런타임 버그 | 빌드 전 발견 |
| 복잡한 함수 | 리뷰어 재량 | 복잡도 임계값 강제 |
| 새 팀원 실수 | 리뷰 피드백 반복 | 즉각 피드백 |

### 수집 가능한 지표

린트를 통해 수집할 수 있는 데이터는 두 가지로 구분된다.

- **프로세스 지표**: "우리 팀이 린트를 얼마나 잘 활용하고 있는가?"를 측정한다. 린트 통과율, 수정 소요 시간 등 팀의 운영 성과를 추적한다. 스프린트 회고, 프로세스 개선에 활용한다.

- **코드 품질 메트릭**: "린트가 코드에서 무엇을 측정하는가?"에 해당한다. 순환 복잡도, 중첩 깊이 등 코드 자체의 품질 속성을 수치화한다. 리팩토링 우선순위 결정, 코드 리뷰 자동화에 활용한다.

<br>

#### 프로세스 지표 (CI/팀 운영 관점)

**지표 A: 린트 오류 수 추이**
- 왜: 코드 품질이 시간에 따라 개선되는지 파악
- 어떻게: CI 실행마다 린트 결과 파싱 → 시계열 DB 저장
- 활용: 스프린트별 품질 추이 대시보드, 급증 시 알림

**지표 B: 규칙별 위반 빈도**
- 왜: 자주 위반되는 규칙 = 팀에게 어려운 규칙 or 불합리한 규칙
- 어떻게: 규칙 ID별 카운트 집계
- 활용: 자주 위반되는 규칙 팀 교육, 불합리한 규칙 완화 검토

**지표 C: 린트 첫 시도 통과율**
- 왜: 팀의 린트 규칙 내재화 수준 측정
- 어떻게: (첫 시도 린트 통과 PR 수 / 전체 PR 수) × 100
- 활용: 팀 목표 설정 (예: 90% 이상 첫 시도 통과)

**지표 D: 린트 수정 소요 시간**
- 왜: 린트 도입 비용 측정
- 어떻게: 린트 실패 → 재시도까지 시간 측정
- 활용: 자동 수정(--fix) 도입 검토, ROI 계산

**지표 E: 린트가 잡은 잠재 버그 수**
- 왜: 린트의 실질적 가치 증명
- 어떻게: "error" 수준 이슈 중 버그 관련 규칙 집계
- 활용: 린트 도입 정당화, 규칙 추가 검토 근거

**지표 F: 신규 이슈 vs 해결 이슈 비율**
- 왜: 기술 부채가 쌓이는지 줄어드는지 파악
- 어떻게: 스프린트별 (새로 발생한 린트 이슈 수) vs (해결된 린트 이슈 수) 비교
- 활용: 기술 부채 관리 방향 결정, "이슈 제로" 스프린트 목표 설정

<br>

#### 코드 품질 메트릭 (린트 도구가 측정하는 값)

**메트릭 1: 순환 복잡도 (Cyclomatic Complexity)**
- 정의: 함수 내 독립적인 실행 경로 수. if, for, while, case 등 분기문이 많을수록 증가
- 측정 도구: ESLint(complexity), PMD, Pylint, mccabe
- 임계값 예시: 10 이하 권장, 20 초과 시 리팩토링 필요
- 활용: 복잡한 함수 조기 발견 → 분리/리팩토링 유도

**메트릭 2: 함수/메서드 길이**
- 정의: 함수당 코드 라인 수
- 측정 도구: ESLint(max-lines-per-function), Checkstyle, Pylint
- 임계값 예시: 50줄 이하 권장, 100줄 초과 시 경고
- 활용: 단일 책임 원칙(SRP) 준수 유도

**메트릭 3: 중첩 깊이 (Nesting Depth)**
- 정의: if/for/while 등 블록이 몇 단계까지 중첩되는지
- 측정 도구: ESLint(max-depth), Checkstyle, Pylint
- 임계값 예시: 4단계 이하 권장
- 활용: 가독성 저해 코드 발견 → early return 패턴 유도

**메트릭 4: 코드 중복률**
- 정의: 동일/유사한 코드 블록이 반복되는 비율
- 측정 도구: PMD CPD, SonarQube, jscpd
- 임계값 예시: 5% 이하 권장
- 활용: 공통 함수 추출, DRY 원칙 준수 유도

**메트릭 5: 파일당 라인 수**
- 정의: 단일 파일의 총 코드 라인 수
- 측정 도구: ESLint(max-lines), Checkstyle
- 임계값 예시: 300줄 이하 권장, 500줄 초과 시 분리 검토
- 활용: 파일 분리 시점 결정, 모듈화 유도

**메트릭 6: 인지 복잡도 (Cognitive Complexity)**
- 정의: 코드를 읽고 이해하는 데 필요한 정신적 노력. 순환 복잡도보다 가독성에 초점
- 측정 도구: SonarQube, ESLint(sonarjs/cognitive-complexity)
- 임계값 예시: 15 이하 권장
- 활용: 유지보수성 낮은 코드 발견

<br>

#### 메트릭 활용 시나리오

**시나리오 1: 스프린트 회고에서 품질 추이 공유**
```
"이번 스프린트에서 린트 오류가 45건 → 12건으로 감소했습니다.
가장 많이 위반된 규칙은 'no-unused-vars'로, 다음 스프린트에서
IDE 경고 설정을 강화하겠습니다."
```

**시나리오 2: 리팩토링 우선순위 결정**
```
복잡도 높은 함수 TOP 5:
1. UserService.processPayment() - 복잡도 28
2. OrderController.validateOrder() - 복잡도 22
...
→ 다음 스프린트 리팩토링 대상으로 선정
```

**시나리오 3: PR 리뷰 자동화**
```
PR 코멘트 자동 생성:
"이 PR에서 복잡도 15 이상 함수가 2개 추가되었습니다.
분리를 검토해주세요: handleUserAction(), processFormData()"
```

<br>

#### 메트릭 수집 도구/방법

| 방법 | 장점 | 단점 |
|------|------|------|
| **CI 로그 파싱** | 추가 도구 불필요 | 구조화된 데이터 추출 어려움 |
| **린트 JSON 출력** | 구조화된 데이터, 파싱 용이 | 별도 스크립트 필요 |
| **SonarQube** | 대시보드 기본 제공, 추이 자동 추적 | 서버 운영 필요 |
| **GitHub Actions Annotations** | PR에서 바로 확인 | 히스토리 추적 어려움 |
| **커스텀 대시보드** | 팀 맞춤 시각화 | 개발/유지보수 비용 |

**린트 JSON 출력 예시:**
```bash
# ESLint
eslint src/ --format json --output-file eslint-report.json

# Ruff
ruff check . --output-format json > ruff-report.json

# Checkstyle (Gradle)
./gradlew checkstyleMain  # build/reports/checkstyle/main.xml 생성
```

### 도입 접근 방식 옵션

**옵션 1: 최소 린트 (Minimal)**
- Error만 차단, Warning 허용
- 필수 규칙만 적용 (10-15개)
- 장점: 개발 속도 유지, 저항 최소화
- 단점: 품질 개선 효과 제한적

**옵션 2: 점진적 강화 (Progressive)**
- 초기: 느슨한 규칙
- 매 스프린트: 1-2개 규칙 추가
- 장점: 팀 적응 시간 확보
- 단점: 일관성 도달까지 시간 소요

**옵션 3: 자동 수정 우선 (Auto-fix First)**
- 자동 수정 가능한 규칙만 활성화
- pre-commit hook으로 자동 수정
- 장점: 개발자 부담 최소화
- 단점: 수동 수정 필요한 중요 규칙 누락

**옵션 4: 신규 코드만 (New Code Only)**
- 기존 코드는 린트 제외
- 신규/수정 코드만 린트 적용
- 장점: 기존 코드 대량 수정 불필요
- 단점: 코드베이스 내 불일치 지속

**옵션 5: 엄격 린트 (Strict)**
- 모든 규칙 활성화
- Warning도 Error로 처리
- 장점: 최고 수준 일관성
- 단점: 초기 저항, 개발 속도 저하

</details>

<details>
<summary><b>Lint 도구별 특성</b></summary>

## Frontend 린트 도구

### ESLint

**강점:**
- JavaScript/TypeScript 생태계의 사실상 표준 린터. 대부분의 프로젝트와 튜토리얼이 ESLint를 기준으로 작성되어 있어 참고 자료가 풍부하다.
- 플러그인 생태계가 매우 크다. React, Vue, TypeScript, 접근성(a11y) 등 프레임워크/목적별 규칙을 플러그인으로 추가할 수 있다.
- 규칙별로 off/warn/error 세밀한 설정이 가능하다. 팀 상황에 맞게 점진적 도입이 용이하다.
- `--fix` 옵션으로 자동 수정 가능한 규칙이 많아 개발자 부담을 줄일 수 있다.

**약점:**
- 설정이 복잡하다. `.eslintrc`, `eslint.config.js` 등 설정 방식이 여러 개 존재하고, 플러그인 간 충돌이 발생할 수 있다.
- 포맷팅(들여쓰기, 줄바꿈 등)은 Prettier와 역할이 겹쳐서 함께 사용 시 충돌 방지 설정이 필요하다.
- 대규모 프로젝트에서 실행 속도가 느릴 수 있다. 캐싱(`--cache`)으로 완화 가능하지만 초기 실행은 느리다.

### Prettier

**강점:**
- 코드 포맷팅에 특화되어 있다. 들여쓰기, 줄바꿈, 따옴표 스타일 등을 일관되게 맞춰준다.
- "Opinionated" 철학으로 설정 옵션이 적다. 팀 내 스타일 논쟁을 원천 차단한다.
- 거의 모든 에디터에서 저장 시 자동 포맷팅을 지원한다. 개발자가 신경 쓸 필요가 없다.
- JavaScript뿐 아니라 HTML, CSS, JSON, Markdown, YAML 등 다양한 언어를 지원한다.

**약점:**
- 코드 품질 검사 기능이 없다. 잠재적 버그, 사용하지 않는 변수 등은 발견하지 못한다. ESLint와 함께 사용해야 한다.
- 옵션이 적어서 팀이 원하는 특정 스타일을 강제하기 어려울 수 있다.
- ESLint와 함께 사용 시 `eslint-config-prettier`로 충돌 규칙을 비활성화해야 한다.

### Biome

**강점:**
- ESLint + Prettier를 하나로 통합한 올인원 도구. 설정 파일 하나로 린트와 포맷팅을 모두 관리한다.
- Rust로 작성되어 매우 빠르다. ESLint 대비 10-20배 빠른 속도를 공식적으로 주장한다.
- 플러그인 충돌 문제가 없다. 모든 규칙이 단일 도구에서 관리된다.
- 2024년 이후 빠르게 성장 중. Rome Tools의 후속으로 활발히 개발되고 있다.

**약점:**
- 생태계가 아직 작다. ESLint 플러그인만큼 다양한 프레임워크별 규칙이 없다.
- React, Vue 등 프레임워크 특화 규칙이 ESLint 대비 부족하다.
- 상대적으로 신생 도구라 레퍼런스가 적고, 문제 발생 시 해결책 찾기가 어려울 수 있다.

<br>

## Backend (Java) 린트 도구

### Checkstyle

**강점:**
- Java 코드 스타일 검사의 표준 도구. Google Java Style, Sun Code Conventions 등 유명 스타일 가이드가 기본 제공된다.
- 네이밍 규칙, 들여쓰기, Javadoc 형식 등 스타일 관련 규칙이 풍부하다.
- Gradle, Maven 플러그인으로 빌드 과정에 쉽게 통합된다.
- XML 설정으로 규칙을 세밀하게 커스터마이징할 수 있다.

**약점:**
- 스타일 검사에 집중하여 잠재적 버그 발견 능력이 약하다. null 참조, 리소스 누수 등은 발견하지 못한다.
- XML 설정이 장황하고 읽기 어렵다. 규칙 수정 시 진입 장벽이 있다.
- 자동 수정 기능이 없다. 위반 사항을 개발자가 직접 수정해야 한다.

### SpotBugs

**강점:**
- 바이트코드 분석으로 잠재적 버그를 발견한다. null 역참조, 무한 루프, 리소스 누수 등 런타임 문제를 사전에 잡는다.
- FindBugs의 후속 프로젝트로, 오랜 역사와 검증된 규칙을 보유한다.
- 보안 취약점 탐지 플러그인(Find Security Bugs)과 함께 사용하면 OWASP 취약점도 발견 가능하다.
- CI에서 실행 시 버그 가능성 높은 코드를 머지 전에 차단할 수 있다.

**약점:**
- 바이트코드 분석이라 컴파일 후에만 실행 가능하다. 빌드 시간이 추가된다.
- 코드 스타일은 검사하지 않는다. Checkstyle과 함께 사용해야 한다.
- False positive가 발생할 수 있다. 특정 패턴을 버그로 오인하는 경우가 있어 예외 처리가 필요하다.

### PMD

**강점:**
- 소스 코드 분석으로 코드 품질 문제를 발견한다. 복잡도 높은 메서드, 중복 코드, 사용하지 않는 변수 등을 탐지한다.
- Copy-Paste Detector(CPD) 기능으로 코드 중복을 찾아낸다.
- Java 외에도 JavaScript, XML, Apex 등 다양한 언어를 지원한다.
- 규칙 커스터마이징과 새 규칙 작성이 상대적으로 용이하다.

**약점:**
- SpotBugs와 규칙이 일부 겹친다. 두 도구를 함께 사용 시 중복 경고가 발생할 수 있다.
- 규칙이 너무 많아 초기 설정 시 어떤 규칙을 활성화할지 선택이 어렵다.
- 일부 규칙의 false positive 비율이 높다는 피드백이 있다.

### SonarLint (+ SonarQube)

**강점:**
- IDE 플러그인으로 코딩 중 실시간 피드백을 제공한다. CI 실행 전에 문제를 발견할 수 있다.
- SonarQube 서버와 연동하면 팀 전체의 코드 품질 대시보드를 구축할 수 있다.
- 버그, 취약점, 코드 스멜, 중복을 통합 분석한다. 별도 도구 조합이 필요 없다.
- 기술 부채를 시간 단위로 시각화한다. "이 문제를 수정하는 데 예상 30분"처럼 표시.

**약점:**
- SonarQube 서버 운영 시 인프라 관리가 필요하다. 클라우드 버전(SonarCloud)은 비용 발생.
- 무료 버전(Community Edition)은 Java, Python 등 일부 언어만 지원. 전체 기능은 유료.
- 초기 설정과 서버 연동이 다른 도구 대비 복잡하다.

<br>

## AI Server (Python) 린트 도구

### Ruff

**강점:**
- Rust로 작성되어 매우 빠르다. Flake8 대비 10-100배 빠른 속도. 대규모 Python 프로젝트에서 체감 효과가 크다.
- Flake8, isort, pyupgrade 등 여러 도구의 규칙을 통합 지원한다. 도구 조합 없이 하나로 해결.
- `--fix` 옵션으로 많은 규칙을 자동 수정한다.
- 2023-2024년 Python 커뮤니티에서 빠르게 채택되고 있다. 활발한 개발과 업데이트.

**약점:**
- 상대적으로 신생 도구(2022년 출시). 레퍼런스가 Flake8, Pylint 대비 적다.
- 타입 검사 기능이 없다. mypy와 별도로 사용해야 한다.
- 일부 Flake8 플러그인의 규칙은 아직 미지원.

### Flake8

**강점:**
- Python 린터의 사실상 표준. 대부분의 Python 프로젝트가 Flake8을 사용하거나 호환된다.
- pycodestyle(PEP8), pyflakes, mccabe를 통합한 래퍼. 스타일 + 에러 + 복잡도를 한번에 검사.
- 플러그인 생태계가 크다. flake8-bugbear, flake8-docstrings 등 목적별 확장 가능.
- 설정이 단순하다. `.flake8` 파일 하나로 관리.

**약점:**
- 실행 속도가 Ruff 대비 느리다. 대규모 프로젝트에서 CI 시간 증가.
- 포맷팅 기능이 없다. Black이나 isort와 함께 사용해야 한다.
- 규칙 자동 수정 기능이 제한적이다. autopep8 등 별도 도구 필요.

### Black

**강점:**
- Python 포맷터의 사실상 표준. "The Uncompromising Code Formatter"를 표방.
- 설정 옵션이 거의 없다. 줄 길이 정도만 설정 가능. 스타일 논쟁을 원천 차단.
- 저장 시 자동 포맷팅으로 개발자가 스타일을 신경 쓸 필요가 없다.
- 대부분의 주요 Python 프로젝트(Django, FastAPI 등)가 Black을 채택.

**약점:**
- 코드 품질 검사 기능이 없다. Flake8/Ruff와 함께 사용해야 한다.
- Black의 스타일이 마음에 안 들어도 바꿀 수 없다. "Opinionated"의 단점.
- 때때로 기존 코드와 다른 포맷팅으로 대량 변경이 발생할 수 있다.

### Pylint

**강점:**
- 가장 엄격하고 포괄적인 Python 린터. 코드 품질에 대한 깊이 있는 분석 제공.
- 규칙 수가 많고 세밀하다. 네이밍, 설계 원칙, 코드 중복 등 광범위하게 검사.
- 코드에 점수(0-10)를 부여한다. 품질을 정량화하여 추적 가능.
- 클래스 설계, 모듈 구조 등 고수준 설계 문제도 지적한다.

**약점:**
- 매우 느리다. Ruff 대비 수십~수백 배 느릴 수 있다.
- 너무 엄격해서 초기 도입 시 대량의 경고가 발생한다. 팀 저항이 클 수 있다.
- False positive가 많다는 평가. 정당한 코드도 경고하는 경우가 있어 예외 처리가 빈번.

### mypy

**강점:**
- Python 정적 타입 검사기. 타입 힌트 기반으로 타입 오류를 빌드 전에 발견한다.
- 런타임에 발생할 타입 불일치 버그를 사전에 잡아낸다.
- 점진적 도입이 가능하다. 타입 힌트가 있는 코드만 검사하고 나머지는 무시할 수 있다.
- IDE 통합(Pylance 등)으로 코딩 중 실시간 타입 오류 표시.

**약점:**
- 스타일이나 코드 품질은 검사하지 않는다. Ruff/Flake8과 별도로 사용해야 한다.
- 타입 힌트가 없는 코드에서는 효과가 제한적이다.
- 서드파티 라이브러리의 타입 스텁이 없으면 타입 검사가 불완전하다.

<br>

## 도구 조합 예시

| 조합 | 구성 | 특징 |
|------|------|------|
| FE 클래식 | ESLint + Prettier | 검증된 조합, 레퍼런스 풍부 |
| FE 모던 | Biome | 빠르고 단순, 신생 도구 |
| BE 최소 | Checkstyle만 | 스타일만 검사, 가볍게 시작 |
| BE 표준 | Checkstyle + SpotBugs | 스타일 + 버그 탐지 |
| BE 통합 | SonarLint + SonarQube | 대시보드, 기술 부채 관리 |
| AI 클래식 | Flake8 + Black + mypy | 검증된 조합 |
| AI 모던 | Ruff + mypy | 빠른 속도, 통합 린팅 |

</details>

<br>

## 부록 B: CI 도구별 상세 비교

<details>
<summary><b>11개 CI 도구 강점/약점 상세</b></summary>

### B.1 GitHub Actions

**개요:** GitHub 네이티브 CI/CD 플랫폼. 2019년 정식 출시.

**강점:**
- GitHub와 네이티브 통합. PR, Issue, 코드 리뷰와 자연스럽게 연동되어 워크플로우가 끊기지 않는다.
- Marketplace에 22,000개 이상의 액션이 있어 대부분의 작업을 재사용 가능한 형태로 구성할 수 있다.
- 별도 서버 운영이 필요 없다. GitHub가 인프라를 관리하므로 CI 서버 장애 대응, 업데이트 등의 부담이 없다.
- Public 레포는 무제한 무료, Private 레포도 월 2,000분/레포 제공.
- YAML 기반 선언적 설정으로 버전 관리 용이.

**약점:**
- GitHub 플랫폼에 종속된다. GitLab이나 Bitbucket으로 이전 시 워크플로우 재작성 필요.
- 복잡한 파이프라인(조건부 분기, 동적 매트릭스 등)은 yml 문법이 장황해질 수 있다.
- Self-hosted runner 없이는 빌드 환경 커스터마이징에 한계가 있다.
- 디버깅이 어렵다. 로컬에서 워크플로우 테스트가 제한적 (act 등 서드파티 필요).

**무료 티어:** Public 레포 무제한, Private 레포 월 2,000분

### B.2 GitLab CI

**개요:** GitLab 내장 CI/CD. DevOps 올인원 플랫폼.

**강점:**
- GitLab은 CI/CD뿐 아니라 이슈 트래커, 위키, 컨테이너 레지스트리, 보안 스캔까지 올인원으로 제공한다.
- Auto DevOps 기능으로 설정 없이도 기본 파이프라인이 자동 구성된다.
- Canary 배포, Blue-Green 배포 등 고급 배포 전략을 내장 지원한다.
- SAST, DAST, 의존성 스캔 등 8종의 보안 검사를 기본 제공한다.
- 다중 프로젝트 파이프라인으로 모노레포/멀티레포 모두 지원.

**약점:**
- 무료 티어는 월 400분으로 제한적이다. 3개 레포를 운영하기엔 부족하다.
- GitLab 플랫폼 사용이 전제된다. GitHub에서 GitLab으로 코드 저장소를 이전해야 GitLab CI의 장점을 온전히 활용할 수 있다.
- 기능이 많아 초기 학습 곡선이 있다.
- Self-managed 버전은 서버 운영 부담 발생.

**무료 티어:** 월 400분 (5 사용자까지)

### B.3 CircleCI

**개요:** 클라우드 네이티브 CI/CD. Docker 친화적.

**강점:**
- Docker 레이어 캐싱과 테스트 병렬 분할 기능이 강점이다.
- 직관적인 UI로 파이프라인 상태를 한눈에 파악할 수 있다.
- 리소스 클래스 선택 등 세밀한 성능 튜닝이 가능하다.
- Orb(재사용 가능한 설정 패키지)로 복잡한 설정을 단순화할 수 있다.
- SSH 디버깅으로 실패한 빌드 환경에 직접 접속 가능.

**약점:**
- 무료 티어는 월 6,000분이지만 조직 전체 공유다.
- GitHub/GitLab 등 외부 플랫폼과 연동해야 하므로 관리 포인트가 분산된다.
- 고급 기능(병렬 실행, 리소스 클래스 업그레이드)은 유료 플랜에서 제대로 활용 가능하다.
- config.yml 문법이 독자적이라 러닝 커브 존재.

**무료 티어:** 월 6,000분 (조직 전체)

### B.4 Jenkins

**개요:** 오픈소스 자동화 서버. 2011년 출시, 업계 표준.

**강점:**
- 완전한 커스터마이징이 가능하다. 1,800개 이상의 플러그인으로 거의 모든 요구사항을 구현할 수 있다.
- 온프레미스 설치로 보안 요구사항이 엄격한 환경에서도 사용 가능하다.
- Groovy 기반 Jenkinsfile로 복잡한 로직을 프로그래밍적으로 작성할 수 있다.
- 커뮤니티가 크고 레퍼런스가 풍부하다.
- Blue Ocean UI로 시각화 개선.

**약점:**
- 별도 서버 운영이 필수다. 서버 프로비저닝, OS 업데이트, Jenkins 버전 업그레이드, 플러그인 호환성 관리 등 지속적인 운영 부담이 발생한다.
- 초기 설정이 복잡하다. 플러그인 선택, 보안 설정, 에이전트 구성 등에 상당한 시간이 소요된다.
- 플러그인 간 호환성 문제가 빈번하다.
- UI가 구식이다 (Blue Ocean 제외).

**무료 티어:** 오픈소스 (서버 비용 별도)

### B.5 Buildkite

**개요:** 하이브리드 CI/CD. 2013년 출시. 대규모 팀에서 인기.

**강점:**
- 하이브리드 방식으로 UI/대시보드는 클라우드에서, 빌드는 자체 인프라에서 실행한다. 보안과 속도를 양립할 수 있다.
- 무제한 병렬 실행이 가능하다. 대규모 모노레포 빌드에 강점.
- 에이전트가 가볍고 Docker/Kubernetes와 잘 통합된다.
- 파이프라인을 코드로 정의 (YAML 또는 JSON).
- Shopify, Canva 등 대규모 팀에서 검증됨.

**약점:**
- Self-hosted runner 운영이 필수다. EC2 인스턴스 관리, 스케일링 설정 등 추가 부담.
- 무료 티어는 월 5,000분이나 runner 비용(AWS 인스턴스 등)이 별도 발생한다.
- 소규모 팀에는 과잉 설정.

**무료 티어:** 월 5,000분 (runner 비용 별도)

### B.6 Travis CI

**개요:** 오픈소스 CI 선구자. 2011년 출시.

**강점:**
- GitHub과 쉽게 연동된다. `.travis.yml` 파일 하나로 CI 설정 완료.
- 오픈소스 프로젝트에서 오랜 기간 사용되어 레퍼런스가 풍부하다.
- 다양한 언어/런타임 사전 설정 제공.

**약점:**
- 2020년 이후 무료 티어 축소, 2025년 4월 macOS 지원 중단 등 기능 축소 추세.
- 새 프로젝트는 크레딧 기반 과금으로 전환되어 비용 예측이 어렵다.
- 장기적 안정성에 불확실성이 있어 신규 도입에 부적합.
- 경쟁사 대비 기능 혁신 정체.

**무료 티어:** 크레딧 기반 (제한적)

### B.7 AWS CodePipeline / CodeBuild

**개요:** AWS 네이티브 CI/CD. AWS 서비스와 긴밀 통합.

**강점:**
- AWS 서비스(CodeBuild, CodeDeploy, ECR, S3 등)와 네이티브 통합된다.
- IAM 기반 세밀한 권한 관리가 가능하다.
- 서버리스로 인프라 관리 부담이 없다.
- VPC 내에서 빌드 실행으로 보안 강화.
- AWS CDK로 파이프라인을 코드로 정의 가능.

**약점:**
- GitHub에서 빌드 상태를 바로 확인하기 어렵다. AWS 콘솔에서 별도 확인 필요.
- buildspec.yml과 GitHub Actions yml 이중 관리 부담.
- AWS 종속성이 심화된다.
- 설정이 복잡하다 (IAM 역할, 정책 등).

**무료 티어:** CodeBuild 월 100분, CodePipeline 월 1개 파이프라인

### B.8 TeamCity

**개요:** JetBrains CI/CD. 2006년 출시. 엔터프라이즈 기능.

**강점:**
- JetBrains IDE(IntelliJ, WebStorm 등)와 긴밀히 통합된다.
- 강력한 빌드 체인, 의존성 관리, 빌드 히스토리 분석 기능.
- 직관적인 웹 UI로 파이프라인 구성이 쉽다.
- Kotlin DSL로 파이프라인을 코드로 정의.
- 빌드 에이전트 풀 관리, 빌드 큐 최적화.

**약점:**
- 서버 운영이 필요하다. 클라우드 버전은 월 $45부터 시작.
- 무료 티어는 빌드 에이전트 3개, 빌드 설정 100개로 제한.
- 소규모 팀에는 과잉 기능.
- 라이선스 비용이 높다 (엔터프라이즈).

**무료 티어:** 에이전트 3개, 빌드 설정 100개

### B.9 Bitbucket Pipelines

**개요:** Atlassian CI/CD. Bitbucket 내장.

**강점:**
- Jira, Confluence, Trello와 네이티브 통합된다. Atlassian 생태계에서 시너지.
- 리포지토리 내 `bitbucket-pipelines.yml`로 간단히 설정.
- 배포 환경(Development, Staging, Production) 관리 기능 내장.
- 배포 권한, 승인 워크플로우 지원.

**약점:**
- Bitbucket 저장소 사용이 전제된다. GitHub → Bitbucket 이전 비용 발생.
- 무료 티어 월 50분으로 매우 제한적. 3개 레포 운영 불가.
- GitHub Actions 대비 Marketplace 생태계 작음.

**무료 티어:** 월 50분

### B.10 Azure Pipelines

**개요:** Microsoft CI/CD. Azure DevOps 일부.

**강점:**
- YAML 기반 설정과 클래식 UI 에디터 중 선택 가능.
- GitHub, GitLab, Bitbucket 등 다양한 저장소 연동 지원.
- 무료 티어 월 1,800분(Public), 1개 병렬 작업(Private) 제공.
- Microsoft 생태계(Azure, VS Code, Teams)와 통합.
- 테스트 결과 시각화, 코드 커버리지 리포트 내장.

**약점:**
- Azure DevOps 플랫폼 계정 필요. 관리 포인트 추가.
- 현재 AWS 배포 환경과 시너지가 낮다.
- YAML 문법이 복잡해질 수 있다.

**무료 티어:** Public 월 1,800분, Private 병렬 1개

### B.11 Google Cloud Build

**개요:** GCP 네이티브 CI/CD. 서버리스.

**강점:**
- 서버리스 CI/CD로 인프라 관리 불필요.
- SLSA level 3 보안 인증. 소프트웨어 공급망 보안에 강점.
- 월 2,500분 무료. GCP 서비스(GKE, Cloud Run, Artifact Registry)와 네이티브 통합.
- 빌드 트리거 다양: GitHub, Cloud Source Repositories, Pub/Sub.
- 프라이빗 풀로 커스텀 빌드 환경 구성 가능.

**약점:**
- GCP 사용이 전제되면 이점이 극대화된다. 현재 FE/BE는 AWS 배포.
- cloudbuild.yaml 설정 필요. GitHub Actions와 이중 관리 부담.
- AI Server가 GCP GPU에 배포되나, CI 도구 통일을 위해 GitHub Actions 선택.
- 디버깅 옵션이 제한적.

**무료 티어:** 월 2,500분 (n1-standard-1)

### B.12 CI 도구 비교 요약표

| 도구 | 유형 | 무료 티어 | 주요 강점 | 주요 약점 |
|------|------|----------|----------|----------|
| GitHub Actions | 클라우드 | Public 무제한 | GitHub 네이티브 통합 | GitHub 종속 |
| GitLab CI | 클라우드/Self | 월 400분 | 올인원 DevOps | GitLab 전제 |
| CircleCI | 클라우드 | 월 6,000분 | Docker 캐싱, 병렬 분할 | 외부 플랫폼 |
| Jenkins | Self-hosted | 무료 (서버비용) | 완전 커스터마이징 | 서버 운영 필수 |
| Buildkite | 하이브리드 | 월 5,000분 | 무제한 병렬 | Self-hosted 필수 |
| Travis CI | 클라우드 | 크레딧 제한 | 간편 설정 | 기능 축소 추세 |
| AWS CodePipeline | 클라우드 | 1 파이프라인 | AWS 통합 | AWS 종속 |
| TeamCity | Self/Cloud | 에이전트 3개 | IDE 통합 | 비용 높음 |
| Bitbucket Pipelines | 클라우드 | 월 50분 | Atlassian 통합 | Bitbucket 전제 |
| Azure Pipelines | 클라우드 | Public 1,800분 | 다양한 저장소 | Azure 플랫폼 |
| Cloud Build | 클라우드 | 월 2,500분 | SLSA 보안 | GCP 전제 |

</details>
